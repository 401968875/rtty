Index: libuwsc-2.0.3/src/log.h
===================================================================
--- libuwsc-2.0.3.orig/src/log.h
+++ libuwsc-2.0.3/src/log.h
@@ -20,7 +20,25 @@
 #ifndef _LOG_H
 #define _LOG_H
 
-#include <libubox/ulog.h>
+#include <syslog.h>
+
+enum {
+	ULOG_KMSG   = (1 << 0),
+	ULOG_SYSLOG = (1 << 1),
+	ULOG_STDIO  = (1 << 2)
+};
+
+void ulog_open(int channels, int facility, const char *ident);
+void ulog_close(void);
+
+void ulog_threshold(int threshold);
+
+void ulog(int priority, const char *fmt, ...);
+
+#define ULOG_INFO(fmt, ...) ulog(LOG_INFO, fmt, ## __VA_ARGS__)
+#define ULOG_NOTE(fmt, ...) ulog(LOG_NOTICE, fmt, ## __VA_ARGS__)
+#define ULOG_WARN(fmt, ...) ulog(LOG_WARNING, fmt, ## __VA_ARGS__)
+#define ULOG_ERR(fmt, ...) ulog(LOG_ERR, fmt, ## __VA_ARGS__)
 
 #define __FILENAME__ (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
 
Index: libuwsc-2.0.3/src/ulog.c
===================================================================
--- /dev/null
+++ libuwsc-2.0.3/src/ulog.c
@@ -0,0 +1,175 @@
+/*
+ * ulog - simple logging functions
+ *
+ * Copyright (C) 2015 Jo-Philipp Wich <jow@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "log.h"
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+static int _ulog_channels = -1;
+static int _ulog_facility = -1;
+static int _ulog_threshold = LOG_DEBUG;
+static int _ulog_initialized = 0;
+static const char *_ulog_ident = NULL;
+
+static const char *ulog_default_ident(void)
+{
+	FILE *self;
+	static char line[64];
+	char *p = NULL;
+	char *sbuf;
+
+	if ((self = fopen("/proc/self/status", "r")) != NULL) {
+		while (fgets(line, sizeof(line), self)) {
+			if (!strncmp(line, "Name:", 5)) {
+				strtok_r(line, "\t\n", &sbuf);
+				p = strtok_r(NULL, "\t\n", &sbuf);
+				break;
+			}
+		}
+		fclose(self);
+	}
+
+	return p;
+}
+
+static void ulog_defaults(void)
+{
+	char *env;
+
+	if (_ulog_initialized)
+		return;
+
+	env = getenv("PREINIT");
+
+	if (_ulog_channels < 0) {
+		if (env && !strcmp(env, "1"))
+			_ulog_channels = ULOG_KMSG;
+		else if (isatty(1))
+			_ulog_channels = ULOG_STDIO;
+		else
+			_ulog_channels = ULOG_SYSLOG;
+	}
+
+	if (_ulog_facility < 0) {
+		if (env && !strcmp(env, "1"))
+			_ulog_facility = LOG_DAEMON;
+		else if (isatty(1))
+			_ulog_facility = LOG_USER;
+		else
+			_ulog_facility = LOG_DAEMON;
+	}
+
+	if (_ulog_ident == NULL && _ulog_channels != ULOG_STDIO)
+		_ulog_ident = ulog_default_ident();
+
+	if (_ulog_channels & ULOG_SYSLOG)
+		openlog(_ulog_ident, 0, _ulog_facility);
+
+	_ulog_initialized = 1;
+}
+
+static void ulog_kmsg(int priority, const char *fmt, va_list ap)
+{
+	FILE *kmsg;
+
+	if ((kmsg = fopen("/dev/kmsg", "r+")) != NULL) {
+		fprintf(kmsg, "<%u>", priority);
+
+		if (_ulog_ident)
+			fprintf(kmsg, "%s: ", _ulog_ident);
+
+		vfprintf(kmsg, fmt, ap);
+		fclose(kmsg);
+	}
+}
+
+static void ulog_stdio(int priority, const char *fmt, va_list ap)
+{
+	FILE *out = stderr;
+
+	if (_ulog_ident)
+		fprintf(out, "%s: ", _ulog_ident);
+
+	vfprintf(out, fmt, ap);
+}
+
+static void ulog_syslog(int priority, const char *fmt, va_list ap)
+{
+	vsyslog(priority, fmt, ap);
+}
+
+void ulog_open(int channels, int facility, const char *ident)
+{
+	ulog_close();
+
+	_ulog_channels = channels;
+	_ulog_facility = facility;
+	_ulog_ident = ident;
+}
+
+void ulog_close(void)
+{
+	if (!_ulog_initialized)
+		return;
+
+	if (_ulog_channels & ULOG_SYSLOG)
+		closelog();
+
+	_ulog_initialized = 0;
+}
+
+void ulog_threshold(int threshold)
+{
+	_ulog_threshold = threshold;
+}
+
+void ulog(int priority, const char *fmt, ...)
+{
+	va_list ap;
+
+	if (priority > _ulog_threshold)
+		return;
+
+	ulog_defaults();
+
+	if (_ulog_channels & ULOG_KMSG)
+	{
+		va_start(ap, fmt);
+		ulog_kmsg(priority, fmt, ap);
+		va_end(ap);
+	}
+
+	if (_ulog_channels & ULOG_STDIO)
+	{
+		va_start(ap, fmt);
+		ulog_stdio(priority, fmt, ap);
+		va_end(ap);
+	}
+
+	if (_ulog_channels & ULOG_SYSLOG)
+	{
+		va_start(ap, fmt);
+		ulog_syslog(priority, fmt, ap);
+		va_end(ap);
+	}
+}
+
Index: libuwsc-2.0.3/src/utils.c
===================================================================
--- libuwsc-2.0.3.orig/src/utils.c
+++ libuwsc-2.0.3/src/utils.c
@@ -102,3 +102,138 @@ const struct ustream_ssl_ops *init_ustre
     return ops;
 }
 #endif
+
+const char *usock_port(int port)
+{
+	static char buffer[sizeof("65535\0")];
+
+	if (port < 0 || port > 65535)
+		return NULL;
+
+	snprintf(buffer, sizeof(buffer), "%u", port);
+
+	return buffer;
+}
+
+static const char Base64[] =
+	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+static const char Pad64 = '=';
+
+/* (From RFC1521 and draft-ietf-dnssec-secext-03.txt)
+   The following encoding technique is taken from RFC 1521 by Borenstein
+   and Freed.  It is reproduced here in a slightly edited form for
+   convenience.
+
+   A 65-character subset of US-ASCII is used, enabling 6 bits to be
+   represented per printable character. (The extra 65th character, "=",
+   is used to signify a special processing function.)
+
+   The encoding process represents 24-bit groups of input bits as output
+   strings of 4 encoded characters. Proceeding from left to right, a
+   24-bit input group is formed by concatenating 3 8-bit input groups.
+   These 24 bits are then treated as 4 concatenated 6-bit groups, each
+   of which is translated into a single digit in the base64 alphabet.
+
+   Each 6-bit group is used as an index into an array of 64 printable
+   characters. The character referenced by the index is placed in the
+   output string.
+
+                         Table 1: The Base64 Alphabet
+
+      Value Encoding  Value Encoding  Value Encoding  Value Encoding
+          0 A            17 R            34 i            51 z
+          1 B            18 S            35 j            52 0
+          2 C            19 T            36 k            53 1
+          3 D            20 U            37 l            54 2
+          4 E            21 V            38 m            55 3
+          5 F            22 W            39 n            56 4
+          6 G            23 X            40 o            57 5
+          7 H            24 Y            41 p            58 6
+          8 I            25 Z            42 q            59 7
+          9 J            26 a            43 r            60 8
+         10 K            27 b            44 s            61 9
+         11 L            28 c            45 t            62 +
+         12 M            29 d            46 u            63 /
+         13 N            30 e            47 v
+         14 O            31 f            48 w         (pad) =
+         15 P            32 g            49 x
+         16 Q            33 h            50 y
+
+   Special processing is performed if fewer than 24 bits are available
+   at the end of the data being encoded.  A full encoding quantum is
+   always completed at the end of a quantity.  When fewer than 24 input
+   bits are available in an input group, zero bits are added (on the
+   right) to form an integral number of 6-bit groups.  Padding at the
+   end of the data is performed using the '=' character.
+
+   Since all base64 input is an integral number of octets, only the
+         -------------------------------------------------
+   following cases can arise:
+
+       (1) the final quantum of encoding input is an integral
+           multiple of 24 bits; here, the final unit of encoded
+	   output will be an integral multiple of 4 characters
+	   with no "=" padding,
+       (2) the final quantum of encoding input is exactly 8 bits;
+           here, the final unit of encoded output will be two
+	   characters followed by two "=" padding characters, or
+       (3) the final quantum of encoding input is exactly 16 bits;
+           here, the final unit of encoded output will be three
+	   characters followed by one "=" padding character.
+   */
+
+int b64_encode(const void *_src, size_t srclength,
+	       void *dest, size_t targsize)
+{
+	const unsigned char *src = _src;
+	char *target = dest;
+	size_t datalength = 0;
+	u_char input[3] = {0};
+	u_char output[4];
+	int i;
+
+	while (2 < srclength) {
+		input[0] = *src++;
+		input[1] = *src++;
+		input[2] = *src++;
+		srclength -= 3;
+
+		output[0] = input[0] >> 2;
+		output[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);
+		output[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);
+		output[3] = input[2] & 0x3f;
+
+		if (datalength + 4 > targsize)
+			return (-1);
+		target[datalength++] = Base64[output[0]];
+		target[datalength++] = Base64[output[1]];
+		target[datalength++] = Base64[output[2]];
+		target[datalength++] = Base64[output[3]];
+	}
+
+	/* Now we worry about padding. */
+	if (0 != srclength) {
+		/* Get what's left. */
+		input[0] = input[1] = input[2] = '\0';
+		for (i = 0; i < srclength; i++)
+			input[i] = *src++;
+
+		output[0] = input[0] >> 2;
+		output[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);
+		output[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);
+
+		if (datalength + 4 > targsize)
+			return (-1);
+		target[datalength++] = Base64[output[0]];
+		target[datalength++] = Base64[output[1]];
+		if (srclength == 1)
+			target[datalength++] = Pad64;
+		else
+			target[datalength++] = Base64[output[2]];
+		target[datalength++] = Pad64;
+	}
+	if (datalength >= targsize)
+		return (-1);
+	target[datalength] = '\0';	/* Returned value doesn't count \0. */
+	return (datalength);
+}
Index: libuwsc-2.0.3/src/utils.h
===================================================================
--- libuwsc-2.0.3.orig/src/utils.h
+++ libuwsc-2.0.3/src/utils.h
@@ -37,4 +37,8 @@ int parse_url(const char *url, char **ho
 const struct ustream_ssl_ops *init_ustream_ssl();
 #endif
 
+const char *usock_port(int port);
+
+int b64_encode(const void *_src, size_t srclength,
+                   void *dest, size_t targsize);
 #endif
Index: libuwsc-2.0.3/src/CMakeLists.txt
===================================================================
--- libuwsc-2.0.3.orig/src/CMakeLists.txt
+++ libuwsc-2.0.3/src/CMakeLists.txt
@@ -12,7 +12,7 @@ find_package(Libubox REQUIRED)
 include_directories(${CMAKE_CURRENT_BINARY_DIR} ${LIBUBOX_INCLUDE_DIR})
 
 set(EXTRA_LIBS ${LIBUBOX_LIBRARY} dl)
-set(SOURCE_FILES uwsc.c log.c utils.c)
+set(SOURCE_FILES uwsc.c log.c utils.c ulog.c)
 
 set(UWSC_SSL_SUPPORT_CONFIG 1)
 option(UWSC_SSL_SUPPORT "SSL support" ON)
